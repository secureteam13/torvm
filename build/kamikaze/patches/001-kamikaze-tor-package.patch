diff -Naur a/package/tor/Makefile b/package/tor/Makefile
--- a/package/tor/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ b/package/tor/Makefile	2009-03-15 09:11:17.875237984 +0000
@@ -0,0 +1,113 @@
+#
+# Copyright (C) 2008 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+# $Id: Makefile 11265 2008-05-25 13:45:00Z blogic $
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=tor
+PKG_VERSION:=0.2.1.13-alpha
+
+PKG_RELEASE:=1
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
+PKG_SOURCE_URL:=http://www.torproject.org/dist/
+PKG_MD5SUM:=eb229b45b23bdf24a7a150332b3c526e
+# XXX MD5 must die ... maybe time for debian embedded
+
+include $(INCLUDE_DIR)/package.mk
+
+define Package/tor
+  SECTION:=net
+  CATEGORY:=Network
+  DEPENDS:=+libevent +libopenssl +libpthread +zlib
+  TITLE:=An anonymous Internet communication system
+  URL:=https://www.torproject.org/
+endef
+
+define Package/tor/description
+ Tor is a toolset for a wide range of organizations and people that want to 
+ improve their safety and security on the Internet. Using Tor can help you 
+ anonymize web browsing and publishing, instant messaging, IRC, SSH, and 
+ more. Tor also provides a platform on which software developers can build 
+ new applications with built-in anonymity, safety, and privacy features.
+endef
+
+define Package/tor/conffiles
+/etc/tor/torrc
+endef
+
+define Package/tor/postinst
+#!/bin/sh
+
+name=tor
+id=52
+
+# do not change below
+# # check if we are on real system
+if [ -z "$${IPKG_INSTROOT}" ]; then
+        # create copies of passwd and group, if we use squashfs
+        rootfs=`mount |awk '/root/ { print $$5 }'`
+        if [ "$$rootfs" = "squashfs" ]; then
+                if [ -h /etc/group ]; then
+                        rm /etc/group
+                        cp /rom/etc/group /etc/group
+                fi
+                if [ -h /etc/passwd ]; then
+                        rm /etc/passwd
+                        cp /rom/etc/passwd /etc/passwd
+                fi
+        fi
+fi
+
+echo ""
+if [ -z "$$(grep ^\\$${name}: $${IPKG_INSTROOT}/etc/group)" ]; then
+        echo "adding group $$name to /etc/group"
+        echo "$${name}:x:$${id}:" >> $${IPKG_INSTROOT}/etc/group
+fi
+
+if [ -z "$$(grep ^\\$${name}: $${IPKG_INSTROOT}/etc/passwd)" ]; then
+        echo "adding user $$name to /etc/passwd"
+        echo "$${name}:x:$${id}:$${id}:$${name}:/tmp/.$${name}:/bin/false" >> $${IPKG_INSTROOT}/etc/passwd
+fi
+endef
+
+EXTRA_CFLAGS += -I$(LINUX_DIR)/include
+EXTRA_CPPFLAGS += -I$(LINUX_DIR)/include
+
+CONFIGURE_ARGS += \
+	--enable-eventdns \
+	--enable-transparent \
+	--enable-threads \
+	--with-libevent-dir="$(STAGING_DIR)/usr" \
+	--with-ssl-dir="$(STAGING_DIR)/usr" \
+
+CONFIGURE_VARS += \
+	CROSS_COMPILE="yes" \
+
+
+# pass CFLAGS again to override -O2 set by configure
+define Build/Compile
+	$(MAKE) -C $(PKG_BUILD_DIR) \
+		CFLAGS="$(TARGET_CFLAGS) -I$(LINUX_DIR)/include" \
+		DESTDIR="$(PKG_INSTALL_DIR)" \
+		all install
+endef
+
+define Package/tor/install
+	$(INSTALL_DIR) $(1)/usr/sbin
+	$(INSTALL_BIN) $(PKG_BUILD_DIR)/src/or/tor $(1)/usr/sbin/
+	$(INSTALL_DIR) $(1)/etc/init.d
+	$(INSTALL_BIN) ./files/tor.init $(1)/etc/init.d/tor
+	$(INSTALL_DIR) $(1)/etc/tor
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/src/config/geoip $(1)/etc/tor/geoip
+	$(INSTALL_DATA) ./files/torrc $(1)/etc/tor/torrc
+	$(INSTALL_DIR) $(1)/var/log/tor
+	$(INSTALL_DIR) $(1)/var/run/tor
+endef
+
+$(eval $(call BuildPackage,tor))
diff -Naur a/package/tor/files/prio.sh b/package/tor/files/prio.sh
--- a/package/tor/files/prio.sh	1970-01-01 00:00:00.000000000 +0000
+++ b/package/tor/files/prio.sh	2009-03-15 04:16:44.189046680 +0000
@@ -0,0 +1,192 @@
+#!/bin/bash
+# Written by Marco Bonetti & Mike Perry
+# Based on instructions from Dan Singletary's ADSL BW Management HOWTO:
+# http://www.faqs.org/docs/Linux-HOWTO/ADSL-Bandwidth-Management-HOWTO.html
+# This script is Public Domain.
+
+############################### README #################################
+
+# This script provides prioritization of Tor traffic below other
+# traffic on a Linux server. It has two modes of operation: UID based 
+# and IP based. 
+
+# UID BASED PRIORITIZATION
+#
+# The UID based method requires that Tor be launched from 
+# a specific user ID. The "User" Tor config setting is
+# insufficient, as it sets the UID after the socket is created.
+# Here is a C wrapper you can use to execute Tor and drop privs before 
+# it creates any sockets. 
+#
+# Compile with:
+# gcc -DUID=`id -u tor` -DGID=`id -g tor` tor_wrap.c -o tor_wrap
+#
+# #include <unistd.h>
+# int main(int argc, char **argv) {
+# if(initgroups("tor", GID) == -1) { perror("initgroups"); return 1; }
+# if(setresgid(GID, GID, GID) == -1) { perror("setresgid"); return 1; }
+# if(setresuid(UID, UID, UID) == -1) { perror("setresuid"); return 1; }
+# execl("/bin/tor", "/bin/tor", "-f", "/etc/tor/torrc", NULL);
+# perror("execl"); return 1;
+# }
+
+# IP BASED PRIORITIZATION
+#
+# The IP setting requires that a separate IP address be dedicated to Tor. 
+# Your Torrc should be set to bind to this IP for "OutboundBindAddress", 
+# "ListenAddress", and "Address".
+
+# GENERAL USAGE
+#
+# You should also tune the individual connection rate parameters below
+# to your individual connection. In particular, you should leave *some* 
+# minimum amount of bandwidth for Tor, so that Tor users are not 
+# completely choked out when you use your server's bandwidth. 30% is 
+# probably a reasonable choice. More is better of course.
+#
+# To start the shaping, run it as: 
+#   ./linux-tor-prio.sh 
+#
+# To get status information (useful to verify packets are getting marked
+# and prioritized), run:
+#   ./linux-tor-prio.sh status
+#
+# And to stop prioritization:
+#   ./linux-tor-prio.sh stop
+#
+########################################################################
+
+# BEGIN USER TUNABLE PARAMETERS
+
+DEV=eth0
+
+# NOTE! You must START Tor under this UID. Using the Tor User
+# config setting is NOT sufficient. See above.
+#TOR_UID=$(id -u tor)
+
+# If the UID mechanism doesn't work for you, you can set this parameter
+# instead. If set, it will take precedence over the UID setting. Note that
+# you need multiple IPs with one specifically devoted to Tor for this to
+# work.
+TOR_IP="$IP"
+
+# Average ping to most places on the net, milliseconds
+RTT_LATENCY=40
+
+# RATE_UP must be less than your connection's upload capacity in
+# kbits/sec. If it is larger, then the bottleneck will be at your
+# router's queue, which you do not control. This will cause congestion
+# and a revert to normal TCP fairness no matter what the queing
+# priority is.
+RATE_UP=1500
+
+# RATE_UP_TOR is the minimum speed your Tor connections will have in
+# kbits/sec.  They will have at least this much bandwidth for upload.
+# In general, you probably shouldn't set this too low, or else Tor
+# users who use your node will be completely choked out whenever your
+# machine does any other network activity. That is not very fun.
+RATE_UP_TOR=1000
+
+# RATE_UP_TOR_CEIL is the maximum rate allowed for all Tor trafic in
+# kbits/sec.
+RATE_UP_TOR_CEIL=1200
+
+#CHAIN=OUTPUT
+#CHAIN=PREROUTING
+CHAIN=POSTROUTING
+
+MTU=$MTU
+AVG_PKT=700
+
+# END USER TUNABLE PARAMETERS
+
+
+
+# The queue size should be no larger than your bandwidth-delay
+# product. This is RT latency*bandwidth/MTU/2
+
+BDP=$(expr $RTT_LATENCY \* $RATE_UP / $AVG_PKT)
+
+# Further research indicates that the BDP calculations should use
+# RTT/sqrt(n) where n is the expected number of active connections..
+
+BDP=$(expr $BDP / 4)
+
+if [ "$1" = "status" ]
+then
+	echo "[qdisc]"
+	tc -s qdisc show dev $DEV
+	tc -s qdisc show dev imq0
+	echo "[class]"
+	tc -s class show dev $DEV
+	tc -s class show dev imq0
+	echo "[filter]"
+	tc -s filter show dev $DEV
+	tc -s filter show dev imq0
+	echo "[iptables]"
+	iptables -t mangle -L TORSHAPER-OUT -v -x 2> /dev/null
+	exit
+fi
+
+
+# Reset everything to a known state (cleared)
+tc qdisc del dev $DEV root 2> /dev/null > /dev/null
+tc qdisc del dev imq0 root 2> /dev/null > /dev/null
+iptables -t mangle -D POSTROUTING -o $DEV -j TORSHAPER-OUT 2> /dev/null > /dev/null
+iptables -t mangle -D PREROUTING -o $DEV -j TORSHAPER-OUT 2> /dev/null > /dev/null
+iptables -t mangle -D OUTPUT -o $DEV -j TORSHAPER-OUT 2> /dev/null > /dev/null
+iptables -t mangle -F TORSHAPER-OUT 2> /dev/null > /dev/null
+iptables -t mangle -X TORSHAPER-OUT 2> /dev/null > /dev/null
+ip link set imq0 down 2> /dev/null > /dev/null
+rmmod imq 2> /dev/null > /dev/null
+
+if [ "$1" = "stop" ]
+then
+	echo "Shaping removed on $DEV."
+	exit
+fi
+
+# Outbound Shaping (limits total bandwidth to RATE_UP)
+
+ip link set dev $DEV qlen $BDP
+
+# Add HTB root qdisc, default is high prio
+tc qdisc add dev $DEV root handle 1: htb default 20
+
+# Add main rate limit class
+tc class add dev $DEV parent 1: classid 1:1 htb rate ${RATE_UP}kbit
+
+# Create the two classes, giving Tor at least RATE_UP_TOR kbit and capping
+# total upstream at RATE_UP so the queue is under our control.
+tc class add dev $DEV parent 1:1 classid 1:20 htb rate $(expr $RATE_UP - $RATE_UP_TOR)kbit ceil ${RATE_UP}kbit prio 0
+tc class add dev $DEV parent 1:1 classid 1:21 htb rate $[$RATE_UP_TOR]kbit ceil ${RATE_UP_TOR_CEIL}kbit prio 10
+
+# Start up pfifo
+tc qdisc add dev $DEV parent 1:20 handle 20: pfifo limit $BDP
+tc qdisc add dev $DEV parent 1:21 handle 21: pfifo limit $BDP
+
+# filter traffic into classes by fwmark
+tc filter add dev $DEV parent 1:0 prio 0 protocol ip handle 20 fw flowid 1:20
+tc filter add dev $DEV parent 1:0 prio 0 protocol ip handle 21 fw flowid 1:21
+
+# add TORSHAPER-OUT chain to the mangle table in iptables
+iptables -t mangle -N TORSHAPER-OUT
+iptables -t mangle -I $CHAIN -o $DEV -j TORSHAPER-OUT
+
+
+# Set firewall marks
+# Low priority to Tor
+if [ ""$TOR_IP == "" ]
+then
+	echo "Using UID-based QoS. UID $TOR_UID marked as low priority."
+	iptables -t mangle -A TORSHAPER-OUT -m owner --uid-owner $TOR_UID -j MARK --set-mark 21
+else
+	echo "Using IP-based QoS. $TOR_IP marked as low priority."
+	iptables -t mangle -A TORSHAPER-OUT -s $TOR_IP -j MARK --set-mark 21
+fi
+
+# High prio for everything else
+iptables -t mangle -A TORSHAPER-OUT -m mark --mark 0 -j MARK --set-mark 20
+
+echo "Outbound shaping added to $DEV.  Rate for Tor upload at least: ${RATE_UP_TOR}Kbyte/sec."
+
diff -Naur a/package/tor/files/tor.init b/package/tor/files/tor.init
--- a/package/tor/files/tor.init	1970-01-01 00:00:00.000000000 +0000
+++ b/package/tor/files/tor.init	2009-03-15 04:23:29.661405512 +0000
@@ -0,0 +1,116 @@
+#!/bin/sh 
+
+BIN=tor
+DEFAULT=/etc/default/$BIN
+HOME_D=/home/$BIN
+CONF_F=$HOME_D/torrc
+GEOIP_F=$HOME_D/geoip
+LOG_D=/var/log/$BIN
+LOG_F=$LOG_D/notices.log
+SLOG_F=$LOG_D/start.log
+DATA_D=$HOME_D/data
+RUN_D=/var/run/$BIN
+PID_F=$RUN_D/$BIN.pid
+RUN_USER=$BIN
+RUN_GROUP=$BIN
+TOR_INTF=eth0
+grep eth1: /proc/net/dev >/dev/null 2>&1
+if [ $? -eq 0 ]; then
+  TOR_INTF=eth1
+fi
+MYIP=$(ifconfig $TOR_INTF | grep 'inet addr' | sed 's/.*inet addr://' | sed 's/ .*//')
+
+if [ "$1" = "start" ]; then
+	[ -f $DEFAULT ] && . $DEFAULT
+	[ -d $HOME_D ] || mkdir -p $HOME_D
+	[ -f $CONF_F ] || cp -f /etc/tor/torrc $CONF_F
+	[ -f $GEOIP_F ] || cp -f /etc/tor/geoip $GEOIP_F
+	[ -d $LOG_D ] || mkdir -p $LOG_D
+	chown $RUN_USER:$RUN_GROUP $LOG_D
+	[ -d $DATA_D ] || mkdir -p $DATA_D
+	chmod 700 $DATA_D
+	chown -R $RUN_USER:$RUN_GROUP $HOME_D
+	[ -d $RUN_D ] || mkdir -p $RUN_D
+	chown $RUN_USER:$RUN_GROUP $RUN_D
+	chmod 700 $RUN_D
+	rm -f $LOG_F >/dev/null 2>&1
+	# append any runtime options as needed
+	TMP_F="${CONF_F}_tmp"; \
+	ARGS=`cat /proc/cmdline` ; \
+	ARGS="_ $ARGS _" ; \
+	echo $ARGS | grep ' HASHPW=' >/dev/null 2>&1 ; \
+	if [ $? -eq 0 ]; then \
+	  HASHPW=`echo $ARGS | sed 's/.* HASHPW=//' | sed 's/ .*//'`; \
+	  cat $CONF_F | grep -v 'HashedControlPassword' > $TMP_F; \
+	  echo "HashedControlPassword ${HASHPW}" >> $TMP_F; \
+	  mv -f $TMP_F $CONF_F; \
+	fi; \
+	echo $ARGS | grep ' CTLSOCK=' >/dev/null 2>&1 ; \
+	if [ $? -eq 0 ]; then \
+	  CTLSOCK=`echo $ARGS | sed 's/.* CTLSOCK=//' | sed 's/ .*//'`; \
+	  CTLPORT=`echo $CTLSOCK | sed 's/.*://'`; \
+	  cat $CONF_F | grep -v 'ControlListenAddress' | grep -v ControlPort > $TMP_F; \
+	  echo "ControlPort ${CTLPORT}" >> $TMP_F; \
+	  echo "ControlListenAddress ${CTLSOCK}" >> $TMP_F; \
+	  mv -f $TMP_F $CONF_F; \
+	fi;
+	chown $RUN_USER:$RUN_GROUP $CONF_F
+	# start tor process
+	$BIN -f $CONF_F $OPTIONS > $SLOG_F 2>&1
+	# TODO for now used fixed control port and socks port accept rule
+	iptables -t nat -I PREROUTING -i $TOR_INTF -d $MYIP -p tcp --dport 9051 -j ACCEPT
+	iptables -t nat -I PREROUTING -i $TOR_INTF -d $MYIP -p tcp --dport 9050 -j ACCEPT
+	# forcibly filter some traffic which should never go over Tor:
+	# no SMTP
+	iptables -t nat -A PREROUTING -i $TOR_INTF -s ! $MYIP -p tcp --dport 25 -j DROP
+	# no TCP DNS
+	iptables -t nat -A PREROUTING -i $TOR_INTF -s ! $MYIP -p tcp --dport 53 -j DROP
+	# no NetBIOS
+	iptables -t nat -A PREROUTING -i $TOR_INTF -s ! $MYIP -p tcp --dport 137 -j DROP
+	iptables -t nat -A PREROUTING -i $TOR_INTF -s ! $MYIP -p tcp --dport 138 -j DROP
+	iptables -t nat -A PREROUTING -i $TOR_INTF -s ! $MYIP -p tcp --dport 139 -j DROP
+	# trans proxy TCP and DNS
+	iptables -t nat -A PREROUTING -i $TOR_INTF -s ! $MYIP -p tcp -j REDIRECT --to 9095
+	iptables -t nat -A PREROUTING -i $TOR_INTF -s ! $MYIP -p udp --dport 53 -j REDIRECT --to 9093
+	# drop everything else ...
+	iptables -t nat -A PREROUTING -i $TOR_INTF -s ! $MYIP -j DROP
+
+elif [ "$1" = "stop" ]; then
+	# XXX TODO: replace this with a fail-safe shutdown
+	iptables -F
+	iptables -t nat -F
+	#[ -f $PID_F ] && kill $(cat $PID_F)
+	killall tor
+
+elif [ "$1" = "restart" ]; then
+	$0 stop
+	$0 start
+
+elif [ "$1" = "status" ]; then
+	while true; do
+	  clear;echo
+	  date
+	  echo
+	  echo "Tor VM local network IP address: $MYIP"
+	  echo
+	  # check if we are fully bootstrapped yet
+	  grep 'Bootstrapped 100' $LOG_F >/dev/null 2>&1
+	  if [ "$?" -ne "0" ]; then
+	  	echo "Tor is still trying to bootstrap into the network..."
+		echo "Be sure the Tor VM clock is correct and that your traffic"
+		echo " is not getting filtered upstream."
+		echo
+	  	grep Bootstrapped $LOG_F | sed 's/.*Bootstrapped/Bootstrapped/' | tail -6
+	  else
+	  	echo "Tor is fully connected into the Tor network."
+	  	echo "Transparent proxy traffic:"
+	  	iptables -n --verbose -t nat --list PREROUTING | sed 's/opt .*destination.*/destination/'|sed 's/    0.0.0.0.0           //'|sed "s/\-\- .*${MYIP}   //"|grep -v PREROUTING
+	  fi
+	  sleep 2
+	done  
+
+else
+	echo "Usage: $0 {start|stop|restart|status}" >&2
+	exit 1
+fi
+exit 0
diff -Naur a/package/tor/files/torrc b/package/tor/files/torrc
--- a/package/tor/files/torrc	1970-01-01 00:00:00.000000000 +0000
+++ b/package/tor/files/torrc	2009-03-15 04:22:14.280865096 +0000
@@ -0,0 +1,27 @@
+# Configuration for Tor VM
+RunAsDaemon 1
+User tor
+Group tor
+PidFile /var/run/tor/pid
+DataDirectory /home/tor/data
+Log notice file /var/log/tor/notices.log
+GeoIPFile /home/tor/geoip
+
+# XXX For now rely on netfilter for access control to transproxy ports
+SocksListenAddress 0.0.0.0
+SocksPort 9050
+TransListenAddress 0.0.0.0
+TransPort 9095
+DNSListenAddress 0.0.0.0
+DNSPort 9093
+
+
+# This needs to be a network available via host default route
+VirtualAddrNetwork 10.254.0.0/16
+
+# Misc. options
+# note that we disable .exit notation to protect against some attacks
+AutomapHostsSuffixes .onion
+AutomapHostsOnResolve 1
+
+# options appended from command line placed below:
